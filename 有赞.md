以下是对您选中问题的回答：

### Java垃圾回收算法有几种，分别是什么？
- **标记-清除算法**：分为标记和清除两个阶段。首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它的主要缺点是会产生大量不连续的内存碎片，空间碎片太多可能会导致后续程序在分配较大对象时无法找到足够的连续内存，从而触发更多的垃圾回收。
- **复制算法**：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这种算法实现简单，运行高效，而且不会产生内存碎片，但内存利用率较低，因为总有一块内存是空闲的。
- **标记-压缩算法**：标记过程与标记-清除算法相同，但在清除阶段，它不是简单地将对象清除，而是将所有存活的对象向一端移动，然后直接清理掉边界以外的内存。该算法解决了标记-清除算法产生内存碎片的问题，同时也避免了复制算法中内存利用率低的缺点，但移动对象时会带来一定的性能开销。
- **分代收集算法**：根据对象存活周期的不同将内存划分为几块，一般是把Java堆分为新生代和老年代。在新生代中，每次垃圾回收时都有大量对象死去，只有少量对象存活，因此采用复制算法；而老年代中对象存活率高，没有额外的空间对它进行分配担保，所以采用标记-清除或标记-压缩算法。

### CMS垃圾收集器采用哪种垃圾回收算法？
CMS（Concurrent Mark Sweep）垃圾收集器主要采用“标记-清除”算法，整个过程分为初始标记、并发标记、重新标记和并发清除等阶段。其中，初始标记和重新标记阶段会暂停用户线程（Stop the World），而并发标记和并发清除阶段则可以与用户线程并发执行。

### CMS垃圾收集器垃圾回收具体过程？
- **初始标记**：暂停所有的用户线程，标记与GC Roots直接相连的对象。这个阶段速度很快，但仍会产生短暂的停顿。
- **并发标记**：从初始标记的对象开始，递归遍历整个对象图，标记出所有可达的对象。此阶段与用户线程并发执行，不会停顿用户线程，但由于对象图遍历和标记的过程较为复杂，可能会占用较多的CPU资源。
- **重新标记**：由于并发标记阶段用户线程在运行，可能会导致部分对象的状态发生变化，所以需要再次暂停用户线程，重新标记这些发生变化的对象。这个阶段的停顿时间通常比初始标记阶段长一些，但比并发标记阶段短很多。
- **并发清除**：清除所有未被标记的对象，即回收垃圾对象占用的内存空间。此阶段与用户线程并发执行，不会影响用户程序的运行。

### CMS垃圾收集器有几次Stop the Word，具体是什么情况发生？
CMS垃圾收集器有两次Stop the World，分别发生在初始标记和重新标记阶段。
- **初始标记阶段**：需要暂停用户线程，因为要快速标记出与GC Roots直接相连的对象。如果不暂停用户线程，在标记过程中对象的引用关系可能会发生变化，导致标记不准确。
- **重新标记阶段**：同样需要暂停用户线程。虽然并发标记阶段已经尽可能地标记了所有可达对象，但由于用户线程的并发执行，可能会出现一些在并发标记期间被修改的对象，这些对象的状态需要重新检查和标记，以确保垃圾回收的准确性。

### G1垃圾收集器过程及特点？
- **过程**：
    - **初始标记**：暂停线程，标记出直接与GC Roots相连的对象。
    - **并发标记**：与用户线程并发执行，从初始标记的对象开始，递归标记整个堆中的可达对象。
    - **最终标记**：暂停线程，处理并发标记阶段结束后仍可能存在的少量对象状态变化。
    - **筛选回收**：根据各个Region的回收价值和成本，选择回收价值高的Region进行回收，采用复制算法将存活对象复制到新的Region中，同时释放旧Region的内存。
- **特点**：
    - **并行与并发**：G1能充分利用多CPU、多核环境下的硬件优势，在垃圾回收阶段实现多线程并行执行，同时还能与用户线程并发执行，减少垃圾回收对应用程序的影响。
    - **分代收集**：G1依然遵循分代收集的思想，将堆内存划分为新生代和老年代，但它不再是简单地按照固定大小和区域来划分，而是将堆内存划分为多个大小相等的Region，每个Region可以根据需要动态地扮演新生代或老年代的角色。
    - **空间整合**：G1在回收内存时，采用复制算法，将存活对象复制到新的Region中，从而避免了内存碎片的产生，实现了空间的有效整合。
    - **可预测的停顿时间模型**：G1通过记录每个Region中垃圾对象的数量、回收所需时间等信息，建立起一个优先级列表，每次根据用户设定的停顿时间目标，优先回收价值高的Region，使得垃圾回收的停顿时间可以在一定程度上得到控制和预测。

### synchronized锁状态，具体膨胀过程？
- **无锁状态**：当一个对象刚被创建时，还没有任何线程访问它，此时对象处于无锁状态，对象头中的Mark Word存储的是对象的哈希码、分代年龄等信息。
- **偏向锁状态**：当第一个线程访问该对象时，会在对象头的Mark Word中记录下当前线程的ID，表示该线程偏向于获取这个锁。在后续的运行过程中，如果该线程再次访问这个对象，只需要检查Mark Word中的线程ID是否与自己的ID一致，如果一致则可以直接获取锁，不需要进行CAS操作等复杂的同步过程，从而提高了性能。
- **轻量级锁状态**：当有第二个线程访问该对象时，发现对象已经处于偏向锁状态，且偏向的线程不是自己，就会尝试使用CAS操作将对象头中的Mark Word替换为指向自己线程栈中锁记录的指针，来获取轻量级锁。如果CAS操作成功，那么当前线程就获得了轻量级锁，对象进入轻量级锁状态；如果CAS操作失败，说明存在竞争，锁就会膨胀为重量级锁。
- **重量级锁状态**：当多个线程竞争锁时，轻量级锁无法解决竞争问题，就会升级为重量级锁。此时，对象头中的Mark Word会指向一个重量级锁的指针，每个访问该对象的线程都会被阻塞，放入到一个等待队列中，由操作系统来进行线程调度，这种方式会带来较大的性能开销。

### 线程池有哪几种？
- **FixedThreadPool**：创建一个固定大小的线程池，线程池中的线程数量是固定的，不会随着任务的提交而增加或减少。当有新任务提交时，如果线程池中有空闲线程，则直接使用空闲线程执行任务；如果线程池中的线程都在忙碌，则新任务会在任务队列中等待，直到有线程空闲出来。
- **CachedThreadPool**：创建一个可缓存的线程池，线程池中的线程数量会根据任务的提交情况动态调整。如果线程池中有空闲线程，会优先使用空闲线程执行任务；如果没有空闲线程，则会创建新的线程来执行任务。当线程空闲一段时间后，会被回收。这种线程池适用于处理大量短时间执行的任务。
- **ScheduledThreadPool**：创建一个定时任务线程池，用于执行定时任务或周期性任务。可以指定任务的延迟执行时间或执行周期，线程池会按照指定的时间规则来执行任务。
- **SingleThreadExecutor**：创建一个单线程的线程池，线程池中只有一个线程来执行任务。所有任务会按照提交的顺序依次在这个线程中执行，保证了任务的顺序执行，适用于需要顺序执行任务且不希望有并发执行情况的场景。

### 单核CPU情况下对多线程任务的影响？
在单核CPU情况下，多线程任务并不会真正地同时执行，而是通过CPU的时间片轮转来实现并发执行的效果。
- **上下文切换开销**：由于CPU需要在不同线程之间频繁切换，每次切换都需要保存当前线程的上下文（如寄存器的值、程序计数器等），并恢复下一个要执行线程的上下文，这会带来一定的时间开销。如果线程切换过于频繁，上下文切换的开销可能会占据大量的CPU时间，从而影响程序的整体性能。
- **资源竞争**：多个线程可能会竞争共享资源，如内存、文件等。在单核CPU环境下，虽然同一时刻只有一个线程在执行，但其他线程可能会在等待资源释放，这可能导致线程的阻塞，进而影响任务的执行效率。
- **并发控制复杂**：为了保证多线程程序的正确性，需要使用各种并发控制机制，如锁、信号量等。在单核CPU环境下，这些并发控制机制同样需要正确使用，否则可能会出现数据不一致、死锁等问题，增加了程序的复杂性和开发难度。

### CAS是什么，优缺点？
- **定义**：CAS（Compare and Swap）是一种硬件级别的原子操作，用于实现多线程环境下的无锁并发控制。它包含三个操作数：内存位置（V）、预期值（A）和新值（B）。CAS操作会将内存位置V中的值与预期值A进行比较，如果相等，则将内存位置V的值更新为新值B，否则不进行任何操作。整个操作是原子的，在硬件层面保证了并发安全性。
- **优点**：
    - **无锁并发**：CAS避免了使用锁带来的线程阻塞和上下文切换开销，提高了并发性能。在高并发场景下，对于一些简单的原子操作，使用CAS可以实现高效的并发控制。
    - **乐观并发**：CAS基于乐观锁的思想，假设在大多数情况下，并发操作不会发生冲突，只有在检测到冲突时才进行处理。这种方式在并发冲突较少的情况下性能较好。
- **缺点**：
    - **ABA问题**：如果一个值从A变为B，再变回A，CAS操作可能会误认为这个值没有发生变化，从而导致错误的更新。可以通过使用版本号等方式来解决ABA问题。
    - **自旋开销**：在CAS操作失败时，通常会通过自旋来不断尝试，直到操作成功。如果自旋时间过长，会浪费大量的CPU资源。特别是在并发冲突比较严重的情况下，自旋可能会导致CPU使用率过高。
    - **不适合复杂操作**：CAS只能用于简单的原子操作，对于复杂的操作，如涉及多个变量的更新，使用CAS实现会比较复杂，并且可能无法保证操作的原子性。

### 线程池的大小如何选定？
线程池大小的选定需要综合考虑多个因素，以下是一些常见的方法和考虑因素：
- **CPU密集型任务**：对于CPU密集型任务，线程池大小一般设置为CPU核心数加1。例如，如果服务器有8个CPU核心，那么线程池大小可以设置为9。加1是为了在某个线程因偶尔的页缺失或其他原因阻塞时，额外的线程可以继续运行，从而充分利用CPU资源。
- **IO密集型任务**：IO密集型任务通常会有大量的时间花费在等待IO操作完成上，而不是CPU计算上。因此，线程池大小可以设置得比CPU核心数大很多，以充分利用等待IO的时间来执行其他任务。一般可以通过公式`线程数 = CPU核心数 * [1 + （IO时间 / CPU时间）]`来估算。例如，一个任务的IO时间是CPU时间的4倍，CPU核心数为8，则线程池大小可以设置为`8 * (1 + 4) = 40`。
- **混合型任务**：如果任务既包含CPU密集型操作，又包含IO密集型操作，可以先分析任务中CPU和IO操作的比例，然后根据上述公式进行估算。或者通过性能测试来确定最佳的线程池大小。
- **系统资源限制**：除了考虑任务类型，还需要考虑系统的资源限制，如内存、网络带宽等。如果线程池过大，可能会导致系统资源耗尽，从而影响整个系统的性能。
- **性能测试和调优**：最终的线程池大小需要通过性能测试来确定。可以在不同的负载条件下，使用不同的线程池大小进行测试，观察系统的响应时间、吞吐量等性能指标，选择性能最佳的线程池大小。同时，在系统运行过程中，也可以根据实际的负载情况动态调整线程池大小。

### Java内存模型中运行时数据区组成？
Java内存模型中的运行时数据区主要由以下几部分组成：
- **程序计数器**：它是一块较小的内存空间，用于记录当前线程所执行的字节码指令的地址。每个线程都有自己独立的程序计数器，因为线程是并发执行的，每个线程都需要有一个独立的计数器来记录自己的执行位置，以便在切换线程时能够正确地恢复执行。
- **Java虚拟机栈**：线程私有的内存区域，用于存储栈帧。栈帧包含了方法执行时的各种信息，如局部变量表、操作数栈、动态链接、方法出口等。当一个方法被调用时，就会在虚拟机栈中压入一个新的栈帧，方法执行完毕后，栈帧就会被弹出。
- **本地方法栈**：与Java虚拟机栈类似，也是线程私有的内存区域，主要用于支持Native方法的执行。不同的是，Java虚拟机栈用于执行Java方法，而本地方法栈用于执行本地方法（通常是用C或C++实现的方法）。
- **Java堆**：是Java虚拟机所管理的内存中最大的一块，被所有线程共享。Java堆用于存储对象实例，几乎所有的对象实例都在堆中分配内存。堆可以分为新生代和老年代，新生代又分为伊甸园区和两个幸存者区，这种分代的设计有助于提高垃圾回收的效率。
- **方法区**：也是被所有线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。在JDK 8及以后的版本中，方法区被元空间（Metaspace）所取代，元空间使用本地内存来存储类元数据，而不是像之前的方法区那样在堆内存中分配。

### Java中元空间存储哪些信息？元空间周期性full GC产生原因？对于项目调优过程？
- **元空间存储的信息**：元空间主要存储类的元数据，包括类的全限定名、类的加载器、类的字节码、类的方法和字段信息、常量池、注解等。它还存储了一些与类加载相关的信息，如类的继承关系、接口实现关系等。此外，运行时常量池中的字符串常量、基本类型常量等也存储在元空间中。
- **元空间周期性full GC产生原因**：
    - **元空间内存不足**：当元空间中存储的类元数据不断增加，达到元空间的内存上限时，就会触发Full GC，以回收不再使用的类元数据，释放内存空间。
    - **类卸载**：如果应用程序动态加载和卸载大量的类，当卸载的类占用的元空间内存达到一定阈值时，也可能会触发Full GC，以清理这些不再使用的类的元数据。
    - **堆内存紧张**：在某些情况下，堆内存紧张可能会导致JVM尝试通过Full GC来回收元空间中的内存，因为元空间和堆内存之间存在一定的关联，Full GC可能会同时对两者进行回收。
- **项目调优过程**：
    - **监控元空间使用情况**：使用JVM监控工具，如JConsole、VisualVM等，实时监控元空间的内存使用情况，包括已使用内存、最大内存、内存增长趋势等。通过监控可以及时发现元空间内存是否存在异常增长或即将达到上限的情况。
    - **分析类加载情况**：检查应用程序中类的加载和卸载情况，确定是否存在不必要的类加载或频繁的类卸载操作。如果发现某些类在加载后很少使用，或者存在大量动态加载但不再使用的类，可以考虑优化类的加载策略，避免不必要的类加载，及时卸载不再使用的类。
    - **调整元空间大小**：根据监控结果和应用程序的实际需求，适当调整元空间的大小。可以通过设置JVM参数`-XX:MetaspaceSize`和`-XX:MaxMetaspaceSize`来指定元空间的初始大小和最大大小。一般来说，可以先根据应用程序的规模和类的数量设置一个合理的初始值，然后根据实际运行情况进行调整。如果元空间频繁触发Full GC，可以尝试增加元空间的大小；如果元空间内存使用一直比较低，可以适当减小元空间的大小。
    - **优化代码和资源使用**：检查应用程序的代码，看是否存在内存泄漏或资源未及时释放的情况，这些问题可能导致元空间内存不断增长。例如，确保及时关闭不再使用的数据库连接、文件流等资源，避免因资源未释放而导致相关的类元数据无法被回收。同时，优化对象的创建和使用，避免创建过多不必要的对象，减少对堆内存和元空间的压力。
    - **升级JDK版本**：不同版本的JDK在元空间的实现和性能方面可能会有所改进。如果应用程序使用的是较旧的JDK版本，可以考虑升级到较新的版本，以利用JDK的性能优化和内存管理改进，可能会改善元空间的性能和稳定性。


以下是对您选中问题的回答：


1. **Java有哪些IO？分别有什么特点和优势？ (BIO、NIO、AIO)**
  - **BIO（Blocking I/O，阻塞式I/O）**：是最传统的Java I/O方式。特点是在进行读写操作时，线程会阻塞等待，直到操作完成。优势是代码简单、容易理解，适用于并发量较小、对实时性要求不高的场景。例如在一些简单的文件读写程序中使用BIO，开发者无需处理复杂的异步逻辑。
  - **NIO（Non - Blocking I/O，非阻塞式I/O）**：从JDK 1.4开始引入，与BIO最大的区别在于读写操作不会阻塞线程。它基于通道（Channel）和缓冲区（Buffer）进行操作，并使用选择器（Selector）来管理多个通道。优势在于能处理高并发场景，提高了系统的并发性能和资源利用率。像一些高性能的网络服务器应用，会利用NIO来处理大量并发的连接请求。
  - **AIO（Asynchronous I/O，异步I/O）**：在JDK 1.7中引入，是基于事件和回调机制实现的异步操作。当进行I/O操作时，线程不会等待操作完成，而是在操作完成时通过回调函数通知线程。优势是进一步提升了异步性能，适用于对响应时间和吞吐量要求极高的场景，比如大规模的分布式系统中的数据读写操作。
2. **Spring Bean生命周期和加载过程？分别有哪几种作用域？**
  - **生命周期和加载过程**：首先，Spring容器启动，读取配置文件或扫描注解来创建Bean定义。接着，实例化Bean对象，如果有构造函数，会调用构造函数进行实例化。然后，进行依赖注入，将Bean所依赖的其他Bean注入进来。之后，如果Bean实现了`BeanNameAware`、`BeanFactoryAware`等接口，会调用相应的方法设置Bean的名称和工厂。再执行Bean的初始化方法（可以通过`@PostConstruct`注解或配置文件中指定的初始化方法）。在容器关闭时，会调用Bean的销毁方法（可以通过`@PreDestroy`注解或配置文件中指定的销毁方法）。
  - **作用域**：常见的有单例（Singleton），在整个Spring容器中只有一个实例；原型（Prototype），每次请求获取Bean时都会创建一个新的实例；请求（Request），在一次HTTP请求中共享一个实例；会话（Session），在一个HTTP会话中共享一个实例；应用程序（Application），在ServletContext范围内共享一个实例 。
3. **Spring有哪些注解？@Transactional注解加载和运行机制？**
  - **常见注解**：`@Component`用于将普通类标记为Spring组件，`@Controller`用于标记Web层的控制器组件，`@Service`用于标记业务逻辑层组件，`@Repository`用于标记数据访问层组件，`@Autowired`用于自动装配Bean，`@RequestMapping`用于处理Web请求映射等。
  - **@Transactional注解加载和运行机制**：`@Transactional`注解可以作用在类或方法上。当作用在方法上时，Spring会在方法调用前创建一个事务，在方法执行过程中，如果发生异常，会根据配置进行事务回滚；如果方法正常执行完毕，会提交事务。其实现原理是基于Spring的AOP（面向切面编程），Spring会为标注了`@Transactional`的方法创建代理对象，在代理对象中添加事务管理的逻辑。
4. **Dubbo负载均衡算法有哪些？如果服务提供者宕机，如何处理？**
  - **负载均衡算法**：常见的有随机（Random）算法，按权重随机选择一个服务提供者；轮询（RoundRobin）算法，按顺序依次选择服务提供者；加权轮询（Weighted RoundRobin）算法，根据服务提供者的权重来轮询选择；最少活跃调用数（LeastActive）算法，优先选择活跃调用数最少的服务提供者 。
  - **服务提供者宕机处理**：Dubbo会通过心跳机制检测服务提供者的状态。当发现服务提供者宕机后，Dubbo会将其从可用服务列表中剔除，不再向其发送请求。同时，Dubbo会根据负载均衡算法，在剩余的可用服务提供者中选择服务，保证系统的正常运行。此外，Dubbo还支持服务降级策略，当某个服务不可用时，可以返回一个默认的结果，避免系统崩溃 。
5. **Zookeeper和CAP原则？**
  - **Zookeeper**：是一个分布式协调服务框架，提供了分布式锁、命名服务、配置管理等功能。它基于Paxos算法的变种Zab协议来保证数据的一致性和可靠性。Zookeeper将数据存储在内存和磁盘中，通过集群模式来提高可用性和性能。
  - **CAP原则**：即一致性（Consistency）、可用性（Availability）、分区容错性（Partition Tolerance）。在分布式系统中，这三个特性无法同时满足，只能满足其中两个。Zookeeper在设计上更注重一致性和分区容错性，在发生网络分区时，Zookeeper会保证数据的一致性，可能会牺牲部分可用性 。
6. **熟悉哪些Linux命令？**
  - **文件操作命令**：`ls`用于列出目录内容，`cd`用于切换目录，`mkdir`用于创建目录，`rm`用于删除文件或目录，`cp`用于复制文件或目录，`mv`用于移动或重命名文件或目录。
  - **文本处理命令**：`cat`用于查看文件内容，`grep`用于在文件中搜索指定字符串，`sed`用于文本替换和处理，`awk`用于文本分析和处理。
  - **进程管理命令**：`ps`用于查看当前进程状态，`top`用于实时监控系统进程资源使用情况，`kill`用于终止进程。
  - **网络命令**：`ping`用于测试网络连接，`ifconfig`用于查看和配置网络接口，`netstat`用于查看网络连接状态。
7. **SSH如何实现免密登陆？**
   通常通过生成密钥对并将公钥添加到目标服务器的授权列表来实现。在本地主机上，使用`ssh - keygen`命令生成密钥对（包括私钥和公钥），然后使用`ssh - copy - id`命令将公钥复制到目标服务器的`~/.ssh/authorized_keys`文件中。这样，以后再使用SSH连接目标服务器时，就无需输入密码了。这是因为本地私钥与目标服务器上的公钥进行匹配验证，验证通过后即可直接登录。
8. **Page Cache(页高速缓存器)？缓存置换算法有哪些？**
  - **Page Cache（页高速缓存器）**：是操作系统内核为了加速对磁盘文件数据的访问而使用的一种缓存机制。它将磁盘文件的部分数据页缓存在内存中，当应用程序需要读取文件数据时，首先在Page Cache中查找，如果找到则直接从内存中读取，避免了磁盘I/O操作，大大提高了数据读取速度。
  - **缓存置换算法**：常见的有先进先出（FIFO）算法，将最先进入缓存的页面置换出去；最近最少使用（LRU，Least Recently Used ）算法，将最近最少使用的页面置换出去；最近未使用（NRU，Not Recently Used ）算法，将一段时间内未被访问的页面置换出去；时钟（Clock）算法，是LRU算法的一种近似实现，通过一个循环链表和一个访问位来模拟LRU的功能 。
9. **为什么TCP协议要进行三次握手和四次挥手？**
  - **三次握手**：为了确保通信双方都能正常收发数据。第一次握手，客户端向服务器发送SYN包，表明客户端想要建立连接；第二次握手，服务器收到SYN包后，向客户端发送SYN + ACK包，确认收到客户端的请求并同意建立连接；第三次握手，客户端收到服务器的SYN + ACK包后，再向服务器发送ACK包，完成连接的建立。这样双方都能确认自己和对方的发送和接收能力正常 。
  - **四次挥手**：因为TCP连接是全双工的，双方都可以发送和接收数据。第一次挥手，客户端向服务器发送FIN包，表明客户端不再发送数据；第二次挥手，服务器收到FIN包后，向客户端发送ACK包，确认收到客户端的关闭请求；第三次挥手，服务器处理完剩余数据后，向客户端发送FIN包，表明服务器也不再发送数据；第四次挥手，客户端收到服务器的FIN包后，向服务器发送ACK包，完成连接的关闭。通过四次挥手，可以确保双方的数据都能完整传输，避免数据丢失 。
10. **输入www.youzan.com会发生什么？会经过哪些组件？**
  - 首先，本地DNS解析器会查询本地DNS缓存，如果没有找到对应域名的IP地址，会向本地DNS服务器发起查询请求。本地DNS服务器可能会继续向根DNS服务器、顶级域名服务器等查询，最终获取到www.youzan.com对应的IP地址。
  - 浏览器根据获取到的IP地址，通过TCP协议与服务器建立连接，进行三次握手。
  - 连接建立后，浏览器向服务器发送HTTP请求，请求访问www.youzan.com的页面资源。
  - 服务器接收到请求后，进行业务逻辑处理，可能会查询数据库获取数据，然后将处理后的HTML页面通过HTTP响应返回给浏览器。
  - 浏览器接收到响应后，解析HTML页面，根据页面中的资源引用（如图片、CSS、JavaScript文件等），再次发起请求获取这些资源。在这个过程中，可能会经过负载均衡器、Web服务器、应用服务器、数据库服务器等组件。负载均衡器负责将请求分发到不同的Web服务器，Web服务器处理静态资源请求，应用服务器处理业务逻辑，数据库服务器提供数据支持 。
11. **MySQL索引原理？B+树优点？聚集索引和非聚集索引优点？**
  - **MySQL索引原理**：索引是一种数据结构，用于快速查找数据库表中的记录。MySQL常见的索引类型有B+树索引、哈希索引等。以B+树索引为例，它将数据按照一定的规则组织成树状结构，通过比较键值来快速定位数据所在的节点，从而减少数据的查找范围，提高查询效率。
  - **B+树优点**：所有数据都存储在叶子节点，并且叶子节点之间通过双向链表连接，方便进行范围查询；非叶子节点只存储键值，不存储数据，因此可以存储更多的键值，使得树的高度更低，查询效率更高；B+树的结构有利于数据库的插入、删除和更新操作，保持较好的性能。
  - **聚集索引优点**：数据按照索引键的顺序存储，在查询时可以直接获取到数据，查询效率高；对于范围查询，由于数据是有序存储的，性能优势明显。
  - **非聚集索引优点**：一个表可以有多个非聚集索引，能为不同的查询条件提供快速查找；非聚集索引不影响数据的物理存储顺序，在插入和更新数据时，相对聚集索引来说，对数据的调整较少，效率较高。
12. **对于一张表t有两列分别是a、b，建立了组合索引，对于select * from t where b = 1 and a > 10这条语句会使用到索引吗？**
    这条语句可能会使用到索引，但不一定能充分利用索引的优势。组合索引的使用遵循“最左前缀原则”，在这条语句中，查询条件先使用了列b，再使用列a，并且列a是范围查询。如果组合索引是按照(a, b)的顺序建立的，那么只能利用到列a的部分索引，无法充分利用组合索引的全部优势；如果组合索引是按照(b, a)的顺序建立的，那么可以使用组合索引来加速查询 。
13. **对于一个查询SQL语句，会查询到非常大的数据量，现要求获取到这些数据第800万页（每页20条数据）的数据，如何对这条SQL语句优化？**
  - 可以使用索引来加速查询，确保查询条件中涉及的列上有合适的索引。如果没有索引，创建索引可能会显著提高查询性能。
  - 采用分页查询时，避免直接使用`LIMIT 160000000, 20`（800万页 * 每页20条数据）这种方式，因为这种方式会跳过前面大量的数据，效率很低。可以利用覆盖索引，结合子查询来优化。例如，先通过覆盖索引查询出符合条件的主键值，再根据主键值查询完整的数据。如`SELECT * FROM t WHERE id IN (SELECT id FROM t WHERE some_condition LIMIT 160000000, 20)` ，这里假设`id`是主键，`some_condition`是其他查询条件。
14. **对于一条select带有锁的语句什么情况下会锁住整张表？**
  - 当使用全表扫描且没有合适的索引来缩小查询范围时，可能会锁住整张表。例如，`SELECT * FROM table_name WITH (TABLOCK)`，这里使用了`TABLOCK`提示，会在查询时锁住整张表。
  - 如果事务隔离级别设置为Serializable（可串行化），在进行查询时，也可能会锁住整张表，以确保事务的一致性和隔离性。因为在Serializable隔离级别下，为了防止并发事务之间的干扰，会对数据进行更严格的锁定 。
15. **对于高并发请求(上万QPS)访问网站获取相关数据，而此时数据库正在更新数据，如何处理旧缓存？如果直接删除缓存，怎么保证高并发量不会压垮系统和数据库？**
  - **处理旧缓存**：可以采用缓存失效策略，在数据库更新数据时，同时更新或删除对应的缓存数据。也可以使用缓存异步更新机制，在数据库更新后，异步通知缓存进行更新，避免高并发时的同步操作压力。
  - **保证系统不被压垮**：使用缓存预热，在系统启动时，提前将部分热点数据加载到缓存中，减少高并发时对数据库的直接访问。同时，采用限流、降级等措施，限制并发请求的数量，当系统压力过大时，返回默认数据或错误信息，避免数据库被大量请求压垮。还可以使用分布式缓存，如Redis集群，提高缓存的性能和容量，分担高并发压力 。
16. **一道智力题，有9个球，其中只有一个质量比其他小球重0.1g，有一架天枰无砝码，至少需要几次使用天枰找到质量大的小球？**
    至少需要2次。把9个球平均分成三组，每组3个球。第一次，将其中两组放在天平两端，如果天平平衡，则质量大的球在没称的那组中；如果天平不平衡，则质量大的球在较重的那组中。第二次，把有质量大的球的那组，任选两个放在天平两端，如果天平平衡，则没称的那个球就是质量大的；如果天平不平衡，则较重的那个球就是要找的 。 
